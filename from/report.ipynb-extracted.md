# 問題3 - 自分のプログラミング言語の拡張（第2・3回の内容から）

- if式
  - 式1つををそもまま置くと文として評価される(構文的にはitem := exprとなっている)ので、if文も実装されているとも言える。
  - `else if` には対応していない。
- 関数
  - 第一級オブジェクト。
  - キャプチャは生成しない。
  - カリー化はされていない。
  - 新たに変数のスコープが作られる。
- 行コメント
  - `//` 始まりの1行をコメントとみなす

サンプルコード(`a.out`のところ)でコメントで追加で説明している。

# 発展問題1 - コード生成（第3回の内容から）

WebAssembly (以下 WASM) のテキスト形式 (WAT) を生成した。

今回作成している言語では、未定義変数のエラー出力では何が未定義なのか出力しなければならない。データ型も数値(double/f64)と関数オブジェクトがあり、どちらも第一級オブジェクトである。また、本言語には静的な型システムが存在ぜず、さらに未定義変数が使用されいる箇所が初めて実行された時にのみエラーを出す。

本言語の制約より、変数の解決や型検査は実行時に行うこととする。
概念的にはインタプリタの時と同様次のような構造体とメソッドが存在するような感じである。

```rust
struct Env(Vec<(String, Value)>);
enum Value {
    F64(f64),
    Func(fn(...)),
}
impl Env {
    fn get_value(name: String) -> Value { ... }
    fn set_value(name: String, value: Value) { ... }
}
```

WASM でこの `Env` を再現するため、WASM の `memory` を利用する。

`Env`で 1 つの変数を表していたタプル `(String, Value)` は次のメモリレイアウトで表すこととした。

```
| text_id (8) | flag (4) | padding (4) | data (8) |  (total 24 byte)

text_id: | ptr (4) | len (4) |
data:
  flag == 0: | f64 (8) |
  flag == 1: | padding (4) | funcref (4) |
```

`text_id` というのが `String` に当たる。今回 WASM の `memory` に文字列をバイト列として格納しているエリアを設けた。`text_id` 上位 4byte がそのエリアへのポインタ(インデックス)、下位 4byte が バイト列の長さである。

`flag` は `data` に格納される `Value` が 小数なのか関数なのかを識別するためのフラグである。0の時小数、1の時関数を意味する。

`data` には `flag` が 0 の時は f64 がそのまま書き込まれている。 `flag`が 1の時は下位 4byte に WASM の `table` へのポインタ(インデックス)が格納されている。
今回 WASM の `table` に関数オブジェクトが列挙されており、それらへの参照を持つことで関数オブジェクトを表現した。

`Env`のメソッド `get_value` と `set_value` は `$get_value` `$set_value` という関数を WAT にて手書きした。
`$get_value` では、引数に与えた `$text_id`という名前がついた値を探し、見つかったら グローバル変数 `$value_f64` または `$value_fun` にその値を保存し、返り値としてその見つかった値がf64なのか関数なのかを表すフラグ(0/1)を返す。フラグの意味は `(String, Value)` のメモリレイアウトで示したものと同じである。
`$set_value` では、引数に与えた `$test_id` という名前で グローバル変数 `$value_f64` または `$value_fun` に記載された値を保存する。どちらを保存するかは 第2引数の `$flag` が決定する。`$flag` の意味は `(String, Value)` のメモリレイアウトで示したフラグと同じである。

`$get_value` と `$set_value` で見たように、本言語で `Value` はグローバル変数 `$value_f64` と `$value_fun` を経由して取り扱われる。
たとえば、`let x = 100` のコンパイルを考えてみると次のようになる。

```wat
i64.const {"x"を指すtext_id}

f64.const 100
global.set $value_f64

i32.const 0
call $set_value
```

また、`x + 100` という式は次のようになる。

```wat
i64.const {"x"を指すtext_id}
call $get_value
call $typecheck_f64

;; 略) 100 をロードして、f64.add を呼ぶ...
```

ここで、`$typecheck_f64` という関数が出てきた。これも WAT にて手書きした関数である。i32を1つ引数に取り、f64を返す関数である。引数のi32は `Value` のフラグである。フラグがf64 (つまり0)を示しているなら グローバル変数 `$value_f64` の値を返し、そうでなければエラーメッセージとともにプログラムを終了させる。プログラムの終了には import した関数`$exit`を使用する。

`$typecheck_f64` と同様な関数として、`$typecheck_fun`が存在し、フラグを検証し、グローバル変数 `$value_fun`の値を返す。

その他細かいところはコード内(C言語で書いたコンパイラ)にコメントで記してある。
